<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/plugins/Arc.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/plugins/Arc.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * mapbox 插件
 * ex: https://docs.mapbox.com/mapbox.js/example/v1.0.0/arcjs/
 */

const D2R = Math.PI / 180;
const R2D = 180 / Math.PI;

export const Coord = function (lon, lat) {
  this.lon = lon;
  this.lat = lat;
  this.x = D2R * lon;
  this.y = D2R * lat;
};

Coord.prototype.view = function () {
  return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4);
};

Coord.prototype.antipode = function () {
  const lat = -1 * this.lat;
  const log = (this.lon &lt; 0) ? 180 + this.lon : (180 - this.lon) * -1;
  return new Coord(log, lat);
};

const LineString = function () {
  this.coords = [];
  this.length = 0;
};

LineString.prototype.move_to = function (coord) {
  this.length++;
  this.coords.push(coord);
};

export const Arc = function (properties) {
  this.properties = properties || {};
  this.geometries = [];
};

Arc.prototype.json = function () {
  if (this.geometries.length &lt;= 0) {
    return {
      'geometry': {
        'type': 'LineString',
        'coordinates': null
      },
      'type': 'Feature',
      'properties': this.properties
    };
  } else if (this.geometries.length === 1) {
    return {
      'geometry': {
        'type': 'LineString',
        'coordinates': this.geometries[0].coords
      },
      'type': 'Feature',
      'properties': this.properties
    };
  } else {
    let multiline = [];
    for (let i = 0; i &lt; this.geometries.length; i++) {
      multiline.push(this.geometries[i].coords);
    }
    return {
      'geometry': {
        'type': 'MultiLineString',
        'coordinates': multiline
      },
      'type': 'Feature',
      'properties': this.properties
    };
  }
};

// TODO - output proper multilinestring
Arc.prototype.wkt = function () {
  let wktString = '';
  let wkt = 'LINESTRING(';
  let collect = function (c) {
    wkt += c[0] + ' ' + c[1] + ',';
  };
  for (let i = 0; i &lt; this.geometries.length; i++) {
    if (this.geometries[i].coords.length === 0) {
      return 'LINESTRING(empty)';
    } else {
      let coords = this.geometries[i].coords;
      coords.forEach(collect);
      wktString += wkt.substring(0, wkt.length - 1) + ')';
    }
  }
  return wktString;
};

/*
 * http://en.wikipedia.org/wiki/Great-circle_distance
 *
 */
export const GreatCircle = function (start, end, properties) {
  if (!start || start.x === undefined || start.y === undefined) {
    throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties');
  }
  if (!end || end.x === undefined || end.y === undefined) {
    throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties');
  }
  this.start = new Coord(start.x, start.y);
  this.end = new Coord(end.x, end.y);
  this.properties = properties || {};
  
  let w = this.start.x - this.end.x;
  let h = this.start.y - this.end.y;
  let z = Math.pow(Math.sin(h / 2.0), 2) +
    Math.cos(this.start.y) *
    Math.cos(this.end.y) *
    Math.pow(Math.sin(w / 2.0), 2);
  this.g = 2.0 * Math.asin(Math.sqrt(z));
  
  if (this.g === Math.PI) {
    throw new Error('it appears ' + start.view() + ' and ' + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
  } else if (isNaN(this.g)) {
    throw new Error('could not calculate great circle between ' + start + ' and ' + end);
  }
};

/*
 * http://williams.best.vwh.net/avform.htm#Intermediate
 */
GreatCircle.prototype.interpolate = function (f) {
  let A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
  let B = Math.sin(f * this.g) / Math.sin(this.g);
  let x = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B * Math.cos(this.end.y) * Math.cos(this.end.x);
  let y = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B * Math.cos(this.end.y) * Math.sin(this.end.x);
  let z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);
  let lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));
  let lon = R2D * Math.atan2(y, x);
  return [lon, lat];
};


/*
 * Generate points along the great circle
 */
GreatCircle.prototype.Arc = function (npoints, options) {
  let firstPass = [];
  if (!npoints || npoints &lt;= 2) {
    firstPass.push([this.start.lon, this.start.lat]);
    firstPass.push([this.end.lon, this.end.lat]);
  } else {
    let delta = 1.0 / (npoints - 1);
    for (let i = 0; i &lt; npoints; ++i) {
      let step = delta * i;
      let pair = this.interpolate(step);
      firstPass.push(pair);
    }
  }
  /* partial port of dateline handling from:
    gdal/ogr/ogrgeometryfactory.cpp

    TODO - does not handle all wrapping scenarios yet
  */
  let bHasBigDiff = false;
  let dfMaxSmallDiffLong = 0;
  // from http://www.gdal.org/ogr2ogr.html
  // -datelineoffset:
  // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)
  let dfDateLineOffset = options &amp;&amp; options.offset ? options.offset : 10;
  let dfLeftBorderX = 180 - dfDateLineOffset;
  let dfRightBorderX = -180 + dfDateLineOffset;
  let dfDiffSpace = 360 - dfDateLineOffset;
  
  // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342
  for (let j = 1; j &lt; firstPass.length; ++j) {
    let dfPrevX = firstPass[j - 1][0];
    let dfX = firstPass[j][0];
    let dfDiffLong = Math.abs(dfX - dfPrevX);
    if (dfDiffLong > dfDiffSpace &amp;&amp;
      ((dfX > dfLeftBorderX &amp;&amp; dfPrevX &lt; dfRightBorderX) || (dfPrevX > dfLeftBorderX &amp;&amp; dfX &lt; dfRightBorderX))) {
      bHasBigDiff = true;
    } else if (dfDiffLong > dfMaxSmallDiffLong) {
      dfMaxSmallDiffLong = dfDiffLong;
    }
  }
  
  let poMulti = [];
  if (bHasBigDiff &amp;&amp; dfMaxSmallDiffLong &lt; dfDateLineOffset) {
    let poNewLS = [];
    poMulti.push(poNewLS);
    for (let k = 0; k &lt; firstPass.length; ++k) {
      let dfX0 = parseFloat(firstPass[k][0]);
      if (k > 0 &amp;&amp; Math.abs(dfX0 - firstPass[k - 1][0]) > dfDiffSpace) {
        let dfX1 = parseFloat(firstPass[k - 1][0]);
        let dfY1 = parseFloat(firstPass[k - 1][1]);
        let dfX2 = parseFloat(firstPass[k][0]);
        let dfY2 = parseFloat(firstPass[k][1]);
        if (dfX1 > -180 &amp;&amp; dfX1 &lt; dfRightBorderX &amp;&amp; dfX2 === 180 &amp;&amp;
          k + 1 &lt; firstPass.length &amp;&amp;
          firstPass[k - 1][0] > -180 &amp;&amp; firstPass[k - 1][0] &lt; dfRightBorderX) {
          poNewLS.push([-180, firstPass[k][1]]);
          k++;
          poNewLS.push([firstPass[k][0], firstPass[k][1]]);
          continue;
        } else if (dfX1 > dfLeftBorderX &amp;&amp; dfX1 &lt; 180 &amp;&amp; dfX2 === -180 &amp;&amp;
          k + 1 &lt; firstPass.length &amp;&amp;
          firstPass[k - 1][0] > dfLeftBorderX &amp;&amp; firstPass[k - 1][0] &lt; 180) {
          poNewLS.push([180, firstPass[k][1]]);
          k++;
          poNewLS.push([firstPass[k][0], firstPass[k][1]]);
          continue;
        }
        
        if (dfX1 &lt; dfRightBorderX &amp;&amp; dfX2 > dfLeftBorderX) {
          // swap dfX1, dfX2
          let tmpX = dfX1;
          dfX1 = dfX2;
          dfX2 = tmpX;
          // swap dfY1, dfY2
          let tmpY = dfY1;
          dfY1 = dfY2;
          dfY2 = tmpY;
        }
        if (dfX1 > dfLeftBorderX &amp;&amp; dfX2 &lt; dfRightBorderX) {
          dfX2 += 360;
        }
        
        if (dfX1 &lt;= 180 &amp;&amp; dfX2 >= 180 &amp;&amp; dfX1 &lt; dfX2) {
          let dfRatio = (180 - dfX1) / (dfX2 - dfX1);
          let dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
          poNewLS.push([firstPass[k - 1][0] > dfLeftBorderX ? 180 : -180, dfY]);
          poNewLS = [];
          poNewLS.push([firstPass[k - 1][0] > dfLeftBorderX ? -180 : 180, dfY]);
          poMulti.push(poNewLS);
        } else {
          poNewLS = [];
          poMulti.push(poNewLS);
        }
        poNewLS.push([dfX0, firstPass[k][1]]);
      } else {
        poNewLS.push([firstPass[k][0], firstPass[k][1]]);
      }
    }
  } else {
    // add normally
    let poNewLS0 = [];
    poMulti.push(poNewLS0);
    for (let l = 0; l &lt; firstPass.length; ++l) {
      poNewLS0.push([firstPass[l][0], firstPass[l][1]]);
    }
  }
  
  let arc = new Arc(this.properties);
  for (let m = 0; m &lt; poMulti.length; ++m) {
    let line = new LineString();
    arc.geometries.push(line);
    let points = poMulti[m];
    for (let j0 = 0; j0 &lt; points.length; ++j0) {
      line.move_to(points[j0]);
    }
  }
  return arc;
};

</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-xdh-map.html">xdh-map</a></li><li><a href="module-xdh-map-circle.html">xdh-map-circle</a></li><li><a href="module-xdh-map-draw.html">xdh-map-draw</a></li><li><a href="module-xdh-map-echarts.html">xdh-map-echarts</a></li><li><a href="module-xdh-map-heat.html">xdh-map-heat</a></li><li><a href="module-xdh-map-html.html">xdh-map-html</a></li><li><a href="module-xdh-map-icon.html">xdh-map-icon</a></li><li><a href="module-xdh-map-image.html">xdh-map-image</a></li><li><a href="module-xdh-map-line.html">xdh-map-line</a></li><li><a href="module-xdh-map-mask.html">xdh-map-mask</a></li><li><a href="module-xdh-map-measure.html">xdh-map-measure</a></li><li><a href="module-xdh-map-overview.html">xdh-map-overview</a></li><li><a href="module-xdh-map-placement.html">xdh-map-placement</a></li><li><a href="module-xdh-map-pointer.html">xdh-map-pointer</a></li><li><a href="module-xdh-map-polygon.html">xdh-map-polygon</a></li><li><a href="module-xdh-map-popup.html">xdh-map-popup</a></li><li><a href="module-xdh-map-rectangle.html">xdh-map-rectangle</a></li><li><a href="module-xdh-map-scatter.html">xdh-map-scatter</a></li><li><a href="module-xdh-map-text.html">xdh-map-text</a></li><li><a href="module-xdh-map-track.html">xdh-map-track</a></li><li><a href="module-xdh-map-type.html">xdh-map-type</a></li><li><a href="module-xdh-map-zoom.html">xdh-map-zoom</a></li></ul><h3>Classes</h3><ul><li><a href="ol.source.TileSuperMapRest.html">TileSuperMapRest</a></li></ul><h3>Events</h3><ul><li><a href="module-xdh-map-type.html#~event:change">change</a></li><li><a href="module-xdh-map.html#~event:changeType">changeType</a></li><li><a href="module-xdh-map-pointer.html#~event:copy">copy</a></li><li><a href="module-xdh-map-draw.html#~event:drawend">drawend</a></li><li><a href="module-xdh-map-draw.html#~event:drawstart">drawstart</a></li><li><a href="module-xdh-map-draw.html#~event:modifyend">modifyend</a></li><li><a href="module-xdh-map-draw.html#~event:modifystart">modifystart</a></li><li><a href="module-xdh-map-track.html#~event:move">move</a></li><li><a href="module-xdh-map.html#~event:ready">ready</a></li><li><a href="module-xdh-map-track.html#~event:start">start</a></li><li><a href="module-xdh-map-track.html#~event:stop">stop</a></li></ul><h3>Global</h3><ul><li><a href="global.html#capitalize">capitalize</a></li><li><a href="global.html#createLayer">createLayer</a></li><li><a href="global.html#createTdtLayer">createTdtLayer</a></li><li><a href="global.html#D2R">D2R</a></li><li><a href="global.html#featureStyleRender">featureStyleRender</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getDistance">getDistance</a></li><li><a href="global.html#getParent">getParent</a></li><li><a href="global.html#keyMap">keyMap</a></li><li><a href="global.html#LAYERS">LAYERS</a></li><li><a href="global.html#mapReady">mapReady</a></li><li><a href="global.html#mix">mix</a></li><li><a href="global.html#mixProps">mixProps</a></li><li><a href="global.html#options">options</a></li><li><a href="global.html#prefix">prefix</a></li><li><a href="global.html#props">props</a></li><li><a href="global.html#set">set</a></li><li><a href="global.html#StyleMap">StyleMap</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Mar 22 2019 10:17:47 GMT+0800 (China Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
